name: cherry-pick

on:
  issue_comment:
    types: [created]

jobs:
  process_comment:
    # This job will parse the cherry-pick command and perform several sanity checks.
    # Ideally we want all pull requests opened from a given command to be correct and successfull, so that
    # developers don't have to reissue a cherry-pick command for a subset of the commits/branches.
    # Therefore, we do all possible sanity checks in this job, before any pull request is opened in subsequent jobs.
    if: github.event.issue.pull_request != '' && contains(github.event.comment.body, 'cherry-pick')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      commits: ${{ steps.command.outputs.commits }}
      branches: ${{ steps.command.outputs.branches }}
      branch_matrix: ${{ steps.command.outputs.branch_matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # We need the history of all branches for the sanity checks
          fetch-depth: 0

      - name: Parse cherry-pick command
        # TODO: make this step into a separate job, so that we can handle more than one command per comment
        id: command
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -f
          command_string=$(echo "${{ github.event.comment.body }}" | grep -m 1 cherry-pick)
          echo "command=$command_string" >> $GITHUB_OUTPUT
          command=($command_string)
          command=("${command[@]:1}")

          has_separator=false
          arg_type=hash
          commits=()
          branches=()
          for token in ${command[@]}; do
            if [[ "$token" == "into" ]]; then
              arg_type=branch
              has_separator=true
            else
              if [[ "$arg_type" == "hash" ]]; then
                commits+=( $token )
              elif [[ "$arg_type" == "branch" ]]; then
                branches+=( $token )
              fi
            fi
          done

          # Check command correctness
          errors=""
          if [[ "$has_separator" = false ]]; then
            errors="$errors\n - the command is missing the \`into\` separator"
          fi
          if [[ -z "$commits" ]]; then
            errors="$errors\n - no list of commits to cherry-pick was provided"
          fi          
          if [[ -z "$branches" ]]; then
            errors="$errors\n - no list of target branches was provided"
          fi          
          if [[ -n "$errors" ]]; then
            message="Incorrect cherry-pick command:"            
            for error in $errors; do
              message="$message\n$error"
            done
            gh pr comment ${{ github.event.issue.number }} --body "> $command_string
            
            Automatic cherry-pick failed. $message"
            while IFS= read -r line; do
              echo "::error::$line"
            done <<< $message
            exit 1
          fi

          # Output lists of commits and branches
          echo "commits=${commits[@]}" >> $GITHUB_OUTPUT
          echo "branches=${branches[@]}" >> $GITHUB_OUTPUT

          # We also output the list of branches as json, so they can be used to generate a matrix for the next job 
          echo "branch_matrix=$(jq -cn '$ARGS.positional' --args -- "${branches[@]}")" >> $GITHUB_OUTPUT

      - name: Check PR status
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check if the PR has been merged
          if [[ -z "${{ github.event.issue.pull_request.merged_at }}" ]]; then
            message="Pull request has not been merged yet. Cannot cherry-pick commits."
            gh pr comment ${{ github.event.issue.number }} --body "> ${{ steps.command.outputs.command }}
            
            $message"
            echo "::error::$message"
            exit 1
          fi

      - name: Check commits
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check that the commits to cherry-pick are actually part of this PRs target branch
          target=$(gh api repos/{owner}/{repo}/pulls/${{ github.event.issue.number }} -q .base.ref)
          missing_commits=""
          for commit in ${{ steps.command.outputs.commits }}; do
            if git merge-base --is-ancestor ${commit} origin/$target; then 
              echo "Commit $commit found in $target branch."
            else
              missing_commits="$missing_commits $commit"
            fi
          done
          if [[ -n "$missing_commits" ]]; then
            message="Could not find commits $missing_commits in [$target](${{ github.repositoryUrl }}/tree/$target)."
            gh pr comment ${{ github.event.issue.number }} --body "> ${{ steps.command.outputs.command }}
            
            Automatic cherry-pick failed. $message"
            echo "::error::$message"
            exit 1
          fi

      - name: Check target branches
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check that cherry-pick target branches actually exist
          missing_branches=""
          for branch in ${{ steps.command.outputs.branches }}; do
            if [[ -n "$(git ls-remote --heads origin ${branch})" ]]; then
              echo "Found branch $branch in repository."
            else
              missing_branches="$missing_branches $branch"
            fi
          done
          if [[ -n "$missing_branches" ]]; then
            message="Could not find branches $missing_branches in repository."
            gh pr comment ${{ github.event.issue.number }} --body "> ${{ steps.command.outputs.command }}
            
            Automatic cherry-pick failed. $message"
            echo "::error::$message"
            exit 1
          fi
        
      - name: Check previous cherry-picks
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check that branches with the cherry-picked commits have not been pushed to the remote yet
          duplicated_branches=""
          for branch in ${{ steps.command.outputs.branches }}; do
            new_branch=cherry_pick_from_pr${{ github.event.issue.number }}_into_$branch
            if [[ -z "$(git ls-remote --heads origin $new_branch)" ]]; then
              echo "No previous attempt to cherry-pick commits from this PR into branch $branch found."
            else
              duplicated_branches="$duplicated_branches $branch"
            fi
          done
          if [[ -n "$duplicated_branches" ]]; then
            message="It seems there are previous unfinished attempts to cherry-pick commits from this PR to the following branches:"
            for branch in $duplicated_branches; do
              message="$message\n  $branch"
            done
            $message="$message\nIf the current cherry-pick attempt is for a different set of commits, make sure that the previous attempts are fully merged and that the corresponding branches have been deleted."
            gh pr comment ${{ github.event.issue.number }} --body "> ${{ steps.command.outputs.command }}
            
            Automatic cherry-pick failed. $message"
            while IFS= read -r line; do
              echo "::error::$line"
            done <<< "$message"
            exit 1
          fi

  create_pr:
    runs-on: ubuntu-latest 
    needs: process_comment
    permissions:
      contents: write
      pull-requests: write
    strategy:
      matrix:
        branch: ${{ fromJson(needs.process_comment.outputs.branch_matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # We need the history of all branches
          fetch-depth: 0
 
      - name: Cherry-pick commits
        id: cherry-pick
        continue-on-error: true
        run: |
          #git config user.name ${{ vars.GH_ACTIONS_BOT_GIT_USER_NAME }}
          #git config user.email ${{ vars.GH_ACTIONS_BOT_GIT_USER_EMAIL }}
          git config user.name "Micael Oliveira"
          git config user.email micael.oliveira@anu.edu.au
        
          new_branch=cherry_pick_from_pr${{ github.event.issue.number }}_into_${{ matrix.branch }}
          echo "new_branch=$new_branch" >> $GITHUB_OUTPUT

          git checkout -b $new_branch origin/${{ matrix.branch }}
          git cherry-pick ${{ needs.process_comment.outputs.commits }}

      - name: Open pull request
        if: steps.cherry-pick.outcome == 'success'
        id: open_pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          #git push --set-upstream origin ${{ steps.cherry-pick.outputs.new_branch }}
          target_link="\[${{ matrix.branch }}\](${{ github.repositoryUrl }}/tree/${{ matrix.branch }})
          url=$(gh pr create -B ${{ matrix.branch }} -t "Cherry-pick commits from #${{ github.event.issue.number }}" \
            -b "Cherry-picking commits ${{ needs.process_comment.outputs.commits }} from #${{ github.event.issue.number }} into $target_link.")
          echo "pr_url=$url" >> $GITHUB_OUTPUT
          echo "target_link=$target_link" >> $GITHUB_OUTPUT
  
      - name: Report success
        if: steps.cherry-pick.outcome == 'success'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          body=$(cat <<- EOM
            Automatic Git cherry-picking of commits ${{ needs.process_comment.outputs.commits }} into ${{ steps.open_pr.outputs.target_link }} was successful.
            
            The new pull request can be reviewed and approved [here](${{ steps.open_pr.outputs.pr_url }}). 
          EOM
          )
          gh pr comment ${{ github.event.issue.number }} --body "$body"

      - name: Manual cherry-pick instructions
        if: steps.cherry-pick.outcome == 'failure'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          body=$(cat <<- EOM
            Automatic Git cherry-picking of commits ${{ needs.process_comment.outputs.commits }} into ${{ steps.open_pr.outputs.target_link }} failed. This usually happens when cherry-picking results in a conflic or an empty commit. To manually cherry-pick the commits and open a pull request, please follow these instructions:
            1. Create new branch from target branch:
            \`\`\`console
            git checkout ${{ matrix.branch }}
            git pull
            git checkout -b ${{ steps.cherry-pick.outputs.new_branch }}
            \`\`\`
            2. Cherry-pick commits:
            \`\`\`console
            git cherry-pick ${{ needs.process_comment.outputs.commits }}
            \`\`\`
            3. Fix any conflicts and/or empty commits by following the instructions provided by Git.
            4. Push the new branch:
            \`\`\`console
            git push --set-upstream origin ${{ steps.cherry-pick.outputs.new_branch }}
            \`\`\`
            5. Open a new pull request on github making sure the target branch is set to ${{ matrix.branch }}.
          EOM
          )
          gh pr comment ${{ github.event.issue.number }} --body "$body"
    
#      - name: Checkout PR
        # Since this is triggerd by a comment, the checkout repository step will
        # checkout the main branch, not the one from the PR.
#        env:
#          GH_TOKEN: ${{ github.token }}
#        run: gh pr checkout ${{ github.event.issue.number }}


#      - name: Dump GitHub context
#        env:
#          GITHUB_CONTEXT: ${{ toJson(github) }}
#        run: echo "$GITHUB_CONTEXT"
